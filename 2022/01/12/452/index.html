<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="Leisurelybear"><meta name="renderer" content="webkit"><meta name="copyright" content="Leisurelybear"><meta name="keywords" content="Leisurelybear's Blog"><meta name="description" content="leisurelybear 的博客，分享科技、数码、编程相关的内容，同时也会分享日常生活记录。"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>由遥控车引起的不可靠的消息服务（监听断连、顺序颠倒、消息丢失）的问题及解决 · LeisurelyBear Blog</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="stylesheet" href="/css/szgotop.css"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><script src="/js/szgotop.js" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Leisurelybear's Blog" type="application/atom+xml">
</head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/favicon_32x32_bear.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">Lebear</div><div class="profile-signature">If you don't like the world, create one instead of complaining.</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 80vh;background-image: url(/img/intro/index-bg.jpg);background-repeat: no-repeat;background-position: top center;background-size: cover;-webkit-background-size: cover; -o-background-size: cover;"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">LeisurelyBear's Blog</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a><a href="/friends/">Friends</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a><a href="/friends/">Friends</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">由遥控车引起的不可靠的消息服务（监听断连、顺序颠倒、消息丢失）的问题及解决</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2022-01-12</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="java"> java</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="TCP"> TCP</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="WebRTC"> WebRTC</a><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="消息队列"> 消息队列</a></span></div><div class="post-intro-read"><span> Word count: <span class="post-count">5.6k</span> | Reading time: <span class="post-count">23</span>min</span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><blockquote>
<p>背景：最近的项目中，有一个端到端控制的场景（即A发送命令，通过RTC服务，使B接收到消息并执行命令），其中为了开发方便使用了RTC服务作为两端通信的“桥梁“。每一组端，都连接到同一个RTC Room，这样一来，多组端都会互不影响。</p>
</blockquote>
<p>上述业务可以简单抽象成下图，<strong>手柄</strong> 发送消息 “<strong>前进5米</strong>“ 到RTC服务器，然后 <strong>遥控车</strong> 接受到该rtc消息后，执行 命令（<strong>前进5米</strong>）。抽象模型和执行流程如下：</p>
<p><img src="https://s4.ax1x.com/2021/12/29/T6lqat.png"></p>
<p>业务抽象表示</p>
<p><img src="https://s4.ax1x.com/2021/12/29/T635Bd.png"></p>
<p>执行流程</p>
<hr>
<p>All right！这一切看起来都是那么美好~~~</p>
<p><strong>但是</strong>！<strong>But</strong>！</p>
<p>这个RTC服务是某不知名厂商提供的<strong>极其不稳定</strong>的服务，具备以下特点：</p>
<ol>
<li><strong>会掉线。</strong></li>
<li><strong>时序不能保证。</strong></li>
<li><strong>可能会丢失消息</strong></li>
</ol>
<p>可谓是条条致命啊！在刚开始的业务中，由于使用并不频繁，所以rtc服务也就相对较”稳定”，上述问题并没有浮现出来。但是在业务扩张后，真的是招招致命啊！</p>
<p>既然使用了rtc，那么就要对她负责！（F**K (╯‵□′)╯︵┻━┻），So， 我们来针对这几个问题分析一下，是否可解？（当然是可解，不然就不会有下文了）</p>
<p><strong>首先，为什么会出现上述问题呢？</strong></p>
<p>通过查阅资料，了解到：WebRTC使用了流控传输协议（SCTP），这个协议啊，其实是很棒的一个协议，同时兼备了TCP和UDP的功能，当然也比较复杂。具有多路复用等优点。通信是先建立四次握手建立SCTP连接，通过channel以流的形式发送消息（如下图），该通道有多路，数据互不干涉，但是当一条通道堵塞后，会导致该连接整体中断。</p>
<p>但是其服务提供者大多场景是在音视频通话，所以并没有启用可靠传输。没错，正是因此，导致时序错误、丢失消息。上面说到的通道阻塞又会导致SCTP连接中断则是掉线的罪魁祸首。</p>
<p><img src="https://s4.ax1x.com/2021/12/30/T2MD3T.png"></p>
<p>SCTP通道，其中msg可以以有序（绿色）发送，也可以以无序（黄色）发送</p>
<hr>
<h2><span id="一-掉线问题">一、掉线问题</span></h2><p>首先解决掉线问题，掉线是个相对不可预测的事件。所以我们可以考虑通过心跳探活和重连机制来处理。</p>
<p>举个例子：小明和小O在通过某信打语音电话，但是小明的网络并不好，所以小明会每隔两分钟向小O问：能听到我讲话嘛？小O回复：可以的。来保证网络正常，通话仍在继续。</p>
<p><img src="https://s4.ax1x.com/2022/01/09/7iHdAK.gif"></p>
<p>以下是实现心跳的简单实现代码，其他细节则可忽略（例如小车移动）。</p>
<p>首先，我们模拟出RTC的实现，主要有RtcEvent接口用来实现事件监听、RtcMessage类统一消息体、RtcClient类则是Rtc的主要操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package rtc;</span><br><span class="line">// 实现消息监听</span><br><span class="line">public interface RtcEvent &#123;</span><br><span class="line">    void handleMessage(RtcMessage msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package rtc;</span><br><span class="line">// 统一化消息体</span><br><span class="line">public class RtcMessage &#123;</span><br><span class="line">    public String key; // 消息的Key</span><br><span class="line">    public int value; // 消息的内容</span><br><span class="line">    public long time; // 消息创建的时间戳</span><br><span class="line"></span><br><span class="line">    public RtcMessage() &#123;</span><br><span class="line">        this.time = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RtcClient也是模拟出来的，这部分主要模拟接收消息、掉线的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package rtc;</span><br><span class="line">// 模拟Rtc功能SDK的实现</span><br><span class="line">public class RtcClient &#123;</span><br><span class="line"></span><br><span class="line">    private boolean shutdown = true;</span><br><span class="line"></span><br><span class="line">    public RtcClient(String uuid) &#123;</span><br><span class="line">        shutdown = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 监听发送来的心跳和消息，用线程来模拟</span><br><span class="line">    public void onListening(RtcEvent e) &#123;</span><br><span class="line"></span><br><span class="line">        // 模拟定时接收心跳的线程</span><br><span class="line">        Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; !shutdown ; i++) &#123;</span><br><span class="line">                RtcMessage heartbeat = new RtcMessage();</span><br><span class="line">                heartbeat.key = null;</span><br><span class="line">                e.handleMessage(heartbeat);</span><br><span class="line">                System.out.println(&quot;心跳：&quot;+ i);</span><br><span class="line"></span><br><span class="line">                // 1、模拟中间接收到消息</span><br><span class="line">                if (i == 10) &#123;</span><br><span class="line">                    // 执行命令</span><br><span class="line">                    RtcMessage cmdMsg = new RtcMessage();</span><br><span class="line">                    cmdMsg.key = &quot;MOVE&quot;;</span><br><span class="line">                    cmdMsg.value = 1000;</span><br><span class="line">                    e.handleMessage(cmdMsg);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 2、模拟掉线</span><br><span class="line">                if (i == 15)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(2000);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 模拟发送出去心跳</span><br><span class="line">    public void send(RtcMessage msg) &#123;</span><br><span class="line">        System.out.println(&quot;send heartbeat: &quot; + msg.time);</span><br><span class="line">        //        e.handleMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 停止</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        // 让线程停止</span><br><span class="line">        this.shutdown = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后我们可以去开发小车端的功能，利用心跳机制，避免断连。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">import rtc.RtcClient;</span><br><span class="line">import rtc.RtcMessage;</span><br><span class="line"></span><br><span class="line">public class Car &#123;</span><br><span class="line"></span><br><span class="line">    // SDK提供的 rtc 客户端</span><br><span class="line">    private static RtcClient rtcClient;</span><br><span class="line">    // 判断小车是否已经开启</span><br><span class="line">    public static volatile boolean isOn;</span><br><span class="line">    // 心跳线程</span><br><span class="line">    private static Thread heartbeatThread;</span><br><span class="line">    // 连接 的 rtc room 的 id</span><br><span class="line">    private String uuid;</span><br><span class="line">    // 上一次心跳时间</span><br><span class="line">    private long lastHeartbeatTime = -1;</span><br><span class="line">    // 死亡沟壑时间，如果超过2000毫秒未接受到心跳，则说明挂了，需要重启client</span><br><span class="line">    public static final int DEAD_GAP_TIME = 2000;</span><br><span class="line"></span><br><span class="line">    public Car(String uuid)&#123;</span><br><span class="line">        this.uuid = uuid;</span><br><span class="line">        rtcClient = new RtcClient(uuid);</span><br><span class="line"></span><br><span class="line">        // 定时发送心跳的线程</span><br><span class="line">        heartbeatThread = new Thread(() -&gt; &#123;</span><br><span class="line">            for(;;)&#123;</span><br><span class="line">                // 探活，是否可以按时接收到心跳，如果不可以，则说明client可能断开连接了，需要重新连接</span><br><span class="line">                checkAndReset();</span><br><span class="line">                System.out.println(&quot;last heartbeat: &quot; + this.lastHeartbeatTime);</span><br><span class="line">                rtcClient.send(new RtcMessage());</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 开启心跳探活线程</span><br><span class="line">        heartbeatThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重置 rtc 连接</span><br><span class="line">     */</span><br><span class="line">    private synchronized void checkAndReset() &#123;</span><br><span class="line">        if (lastHeartbeatTime == -1)&#123;</span><br><span class="line">            // 刚初始化，跳过</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果超过2000毫秒未接受到心跳，则说明挂了，需要重启client</span><br><span class="line">        if (System.currentTimeMillis() - lastHeartbeatTime &gt; DEAD_GAP_TIME)&#123;</span><br><span class="line">            if(rtcClient != null)&#123;</span><br><span class="line">                rtcClient.close();</span><br><span class="line">            &#125;</span><br><span class="line">            // 重新建立连接</span><br><span class="line">            rtcClient = new RtcClient(this.uuid);</span><br><span class="line">            startUp();// 重新监听</span><br><span class="line">            System.out.println(&quot;reset: &quot;+ rtcClient);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开启小车</span><br><span class="line">     */</span><br><span class="line">    public synchronized void startUp()&#123;</span><br><span class="line"></span><br><span class="line">        // 开始监听 uuid room 的 rtc的消息</span><br><span class="line">        rtcClient.onListening(receiveMsg -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            // 判断如果是心跳，则更新上一次探活时间</span><br><span class="line">            if (receiveMsg.key == null)&#123;</span><br><span class="line">                lastHeartbeatTime = receiveMsg.time;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                // 执行rtc消息传来的命令，让小车进行相应的动作</span><br><span class="line">                executeCommand(receiveMsg.key, receiveMsg.value);</span><br><span class="line">                System.out.println(&quot;[ Cmd: &quot; + receiveMsg.key + &quot;, val: &quot; + receiveMsg.value + &quot; ]&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行命令</span><br><span class="line">     * @param cmd 对应的指令</span><br><span class="line">     * @param v 值</span><br><span class="line">     */</span><br><span class="line">    private void executeCommand(String cmd, int v)&#123;</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">            case &quot;MOVE&quot;:</span><br><span class="line">                move(v);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;SPIN&quot;:</span><br><span class="line">                spin(v);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移动距离</span><br><span class="line">     * @param distance 距离</span><br><span class="line">     */</span><br><span class="line">    private void move(int distance)&#123;</span><br><span class="line">        System.out.println(&quot;move &quot; + distance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 旋转角度</span><br><span class="line">     * @param angle 角度</span><br><span class="line">     */</span><br><span class="line">    private void spin(int angle)&#123;</span><br><span class="line">        System.out.println(&quot;spin &quot; + angle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，我们可以发现，对于连接断开的问题，我们通过心跳机制顺利解决~即在心跳间隔大于一定时间时候则判定断开连接，这个时候就要重新连接。至此，我们已经解决了第一个问题。</p>
<p>我们通过一个Demo程序，看一下心跳效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DemoMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Car c = new Car(&quot;10086&quot;);</span><br><span class="line">        c.startUp();</span><br><span class="line">        Thread.sleep(10000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s4.ax1x.com/2022/01/11/7ZQQUg.png"></p>
<hr>
<h2><span id="二-消息时序问题">二、消息时序问题</span></h2><p>我们上面的代码是在Client中开启线程，使用for循环，来模拟心跳（heartbeat）以及命令（Command）。在实际生产环境中，心跳可以使用for循环来实现；但是命令是随时可能发送的，然而我们使用的SCTP协议的时候没有保证消息接受的顺序，所以会产生什么问题呢？看下面的gif，蓝色表示木板，黄色箭头表示小车和车头方向。</p>
<p>正常情况下，控制器发送三条命令，依次是 移动1、旋转90°、移动1。小车按顺序接收命令，则可以顺利到达指定位置（图2-1）。</p>
<p><img src="https://s4.ax1x.com/2022/01/09/7kmTeA.gif"></p>
<p>图2-1 正常情况</p>
<p>但是，如果消息并不是按顺序到达，而是乱序，就会出现下面的情况（图2-2），先接收到 SPIN，然后接收到 MOVE，就会导致小车从木板上掉落下去。</p>
<p><img src="https://s4.ax1x.com/2022/01/09/7knwkt.gif"></p>
<p>图2-2 乱序情况</p>
<p>显然，我们应该避免（图2-2）这样的情况，所以如何解决呢？我们可以借鉴TCP的机制。</p>
<p>既然大家看到了这篇文章，想必大家都或多或少了解TCP协议吧，在TCP协议中，通过SEQ和ACK的机制来确保报文顺序。具体是指发送方将要发送的数据分割成合适大小的报文段，然后在每个报文段标上序号，这个序号就是SEQ，接收端在接收到报文后，发送ACK来反馈自己已经接受到的数据报文，以及通知发送方下次发送的报文序列号。这个期间，接收方可能以乱序的形式接受到这些报文，那么在接收后，对报文进行排序，即可达到数据顺序正确的目的。</p>
<p><img src="https://s4.ax1x.com/2022/01/09/7kMESf.png"></p>
<p>图源自网络（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/silyvin/p/11927398.html%EF%BC%89">https://www.cnblogs.com/silyvin/p/11927398.html）</a></p>
<p>分析到这里，我们可以试一试走Seq这条路，给每个消息打上Seq，然后通过Seq来保证时序，这里先以简单的实现方式来出发，不考虑消息丢失，只考虑消息乱序。</p>
<p>首先，改造RtcMessage，使其支持消息序号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package rtc;</span><br><span class="line"></span><br><span class="line">public class RtcMessage implements Comparable&lt;RtcMessage&gt; &#123;</span><br><span class="line">    public String key;</span><br><span class="line">    public int value;</span><br><span class="line">    public long time;</span><br><span class="line">    public long seq;</span><br><span class="line"></span><br><span class="line">    public RtcMessage() &#123;</span><br><span class="line">        this.time = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override // 实现比较，为了让消息自排序，后面会讲为什么要实现这个方法</span><br><span class="line">    public int compareTo(RtcMessage o) &#123;</span><br><span class="line">        if (this.seq &gt; o.seq) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后改造RtcClient，模拟发送多条指令，以多线程的方式发送，并携带序号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">package rtc;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class RtcClient &#123;</span><br><span class="line"></span><br><span class="line">    // 使用标志位来控制线程的停止</span><br><span class="line">    private boolean shutdown = true;</span><br><span class="line"></span><br><span class="line">    public RtcClient(String uuid) &#123;</span><br><span class="line">        shutdown = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 监听发送来的心跳和消息，用线程来模拟</span><br><span class="line">    public void onListening(RtcEvent e) &#123;</span><br><span class="line"></span><br><span class="line">        // 定时发送心跳的线程</span><br><span class="line">        Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; !shutdown ; i++) &#123;</span><br><span class="line">                RtcMessage heartbeat = new RtcMessage();</span><br><span class="line">                heartbeat.key = null;</span><br><span class="line">                e.handleMessage(heartbeat);</span><br><span class="line">                System.out.println(&quot;心跳：&quot;+ i);</span><br><span class="line"></span><br><span class="line">                // 模拟中间接收到消息</span><br><span class="line">                if (i == 10) &#123;</span><br><span class="line"></span><br><span class="line">                    // 正确顺序，0-MOVE、1-SPIN、2-MOVE、3-SPIN、4-MOVE</span><br><span class="line">                    // 先生成顺序消息</span><br><span class="line">                    List&lt;RtcMessage&gt; msgList = new ArrayList&lt;&gt;(); // 使用list装</span><br><span class="line">                    for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">                        RtcMessage cmdMsg = new RtcMessage();</span><br><span class="line">                        if ((j &amp; 1) == 0)&#123;</span><br><span class="line">                            // 执行命令</span><br><span class="line">                            cmdMsg.key = &quot;MOVE&quot;;</span><br><span class="line">                            cmdMsg.value = 1000;</span><br><span class="line">                        &#125;else &#123;</span><br><span class="line">                            // 执行命令</span><br><span class="line">                            cmdMsg.key = &quot;SPIN&quot;;</span><br><span class="line">                            cmdMsg.value = 90;</span><br><span class="line">                        &#125;</span><br><span class="line">                        cmdMsg.seq = j;</span><br><span class="line">                        msgList.add(cmdMsg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 然后开启多线程发送指令</span><br><span class="line">                    msgList.forEach(msg -&gt; &#123;</span><br><span class="line">                        new Thread(() -&gt; &#123;</span><br><span class="line">                            e.handleMessage(msg);</span><br><span class="line">                        &#125;).start();</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 模拟掉线</span><br><span class="line">                if (i == 15)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(2000);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 模拟发送出去心跳</span><br><span class="line">    public void send(RtcMessage msg) &#123;</span><br><span class="line">        System.out.println(&quot;send heartbeat: &quot; + msg.time);</span><br><span class="line">        //        e.handleMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 停止</span><br><span class="line">    public void close() &#123;</span><br><span class="line">        // 让线程停止</span><br><span class="line">        this.shutdown = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，我们在Car中打印出执行的指令和序列号，出现了下面的情况，小车接收到的指令顺序并不正确，但是如果我们直接按照这个顺序执行（转180°，再走3000米），就会出大问题；而我们期望的是（走1000米，转90°，走1000米，转90°，走1000米）。</p>
<p><img src="https://s4.ax1x.com/2022/01/11/7ZQs2R.png"></p>
<p>我们上文中引入了Seq的概念，所以接下来，我们在小车接收端（Car）也使用以下吧~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">import rtc.RtcClient;</span><br><span class="line">import rtc.RtcMessage;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.PriorityBlockingQueue;</span><br><span class="line">import java.util.concurrent.atomic.AtomicLong;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class Car &#123;</span><br><span class="line"></span><br><span class="line">    // SDK提供的 rtc 客户端</span><br><span class="line">    private static RtcClient rtcClient;</span><br><span class="line">    // 判断小车是否已经开启</span><br><span class="line">    public static volatile boolean isOn;</span><br><span class="line">    // 心跳线程</span><br><span class="line">    private static Thread heartbeatThread;</span><br><span class="line">    // 连接 的 rtc room 的 id</span><br><span class="line">    private String uuid;</span><br><span class="line">    // 上一次心跳时间</span><br><span class="line">    private long lastHeartbeatTime = -1;</span><br><span class="line">    // 死亡沟壑时间，如果超过2000毫秒未接受到心跳，则说明挂了，需要重启client</span><br><span class="line">    private static final int DEAD_GAP_TIME = 2000;</span><br><span class="line">    // 记录上一次消费的命令Seq</span><br><span class="line">    private static final AtomicLong lastSeq = new AtomicLong();</span><br><span class="line">    // 顺序队列</span><br><span class="line">    private static final PriorityBlockingQueue&lt;RtcMessage&gt; waitingQueue = new PriorityBlockingQueue&lt;&gt;();</span><br><span class="line">    // 锁</span><br><span class="line">    private static final ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public Car(String uuid) &#123;</span><br><span class="line">        this.uuid = uuid;</span><br><span class="line">        rtcClient = new RtcClient(uuid);</span><br><span class="line"></span><br><span class="line">        // 定时发送心跳的线程</span><br><span class="line">        heartbeatThread = new Thread(() -&gt; &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                // 探活，是否可以按时接收到心跳，如果不可以，则说明client可能断开连接了，需要重新连接</span><br><span class="line">                checkAndReset();</span><br><span class="line">                System.out.println(&quot;last heartbeat: &quot; + this.lastHeartbeatTime);</span><br><span class="line">                rtcClient.send(new RtcMessage());</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 开启心跳探活线程</span><br><span class="line">        heartbeatThread.start();</span><br><span class="line">        initMsgWaitingQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化命令消费等待队列，开启线程，轮询等待队列，做到有顺序消费（执行命令）</span><br><span class="line">     */</span><br><span class="line">    private void initMsgWaitingQueue() &#123;</span><br><span class="line">        // 初始化首次消费命令顺序为0，以后每消费一次，序列号都+1，这个在tcp中可以作为ACK</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(&quot;wait for command...&quot;);</span><br><span class="line">                if (waitingQueue.size() == 0) &#123;</span><br><span class="line">                    // 还没有消息</span><br><span class="line">//                    System.out.println(&quot;null message.&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    RtcMessage receiveMsg = waitingQueue.peek();</span><br><span class="line"></span><br><span class="line">                    // 如果本次有消息</span><br><span class="line">                    // 如果这次的消息序列号不等于上次+1，即 seq != lastSeq + 1，则还需要再把它入队列，再等等</span><br><span class="line">                    if (receiveMsg.seq != lastSeq.get()) &#123;</span><br><span class="line">                        // 既然不相等，那就需要再减回去</span><br><span class="line">                        System.out.printf(&quot;receiveMsg seq: %d, last seq: %d\n&quot;, receiveMsg.seq, lastSeq.get());</span><br><span class="line">                        System.out.println(&quot;not sequence message, continue wait...&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 若 seq = lastSeq + 1，则直接执行命令，进行消费</span><br><span class="line">                        executeCommand(receiveMsg.key, receiveMsg.value);</span><br><span class="line">                        lastSeq.addAndGet(1); // 标记上次消费的位置</span><br><span class="line">                        System.out.println(&quot;[ Seq: &quot; + receiveMsg.seq + &quot;, Cmd: &quot; + receiveMsg.key + &quot;, val: &quot; + receiveMsg.value + &quot; ]&quot;);</span><br><span class="line">                        waitingQueue.poll();</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.unlock();</span><br><span class="line"></span><br><span class="line">                // 等一下消息吧</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重置 rtc 连接</span><br><span class="line">     */</span><br><span class="line">    private synchronized void checkAndReset() &#123;</span><br><span class="line">        if (lastHeartbeatTime == -1)&#123;</span><br><span class="line">            // 刚初始化，跳过</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果超过2000毫秒未接受到心跳，则说明挂了，需要重启client</span><br><span class="line">        if (System.currentTimeMillis() - lastHeartbeatTime &gt; DEAD_GAP_TIME) &#123;</span><br><span class="line">            if (rtcClient != null) &#123;</span><br><span class="line">                rtcClient.close();</span><br><span class="line">            &#125;</span><br><span class="line">            // 重新建立连接</span><br><span class="line">            rtcClient = new RtcClient(this.uuid);</span><br><span class="line">            startUp();// 重新监听</span><br><span class="line">            System.out.println(&quot;reset: &quot; + rtcClient);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开启小车</span><br><span class="line">     */</span><br><span class="line">    public synchronized void startUp() &#123;</span><br><span class="line"></span><br><span class="line">        // 开始监听 uuid room 的 rtc的消息</span><br><span class="line">        rtcClient.onListening(receiveMsg -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            // 判断如果是心跳，则更新上一次探活时间</span><br><span class="line">            if (receiveMsg.key == null) &#123;</span><br><span class="line">                lastHeartbeatTime = receiveMsg.time;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 执行rtc消息传来的命令，让小车进行相应的动作</span><br><span class="line">//                executeCommand(receiveMsg.key, receiveMsg.value);</span><br><span class="line">//                System.out.println(&quot;[ Seq: &quot; + receiveMsg.seq + &quot;, Cmd: &quot; + receiveMsg.key + &quot;, val: &quot; + receiveMsg.value + &quot; ]&quot;);</span><br><span class="line">                addWaitingQueue(receiveMsg); // 添加等待队列，来代替直接消费，这里使用优先队列保证顺序</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @param receiveMsg 接收到的消息</span><br><span class="line">     */</span><br><span class="line">    private void addWaitingQueue(RtcMessage receiveMsg) &#123;</span><br><span class="line">        // 加个锁吧~</span><br><span class="line">        lock.lock();</span><br><span class="line">        waitingQueue.offer(receiveMsg);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行命令</span><br><span class="line">     *</span><br><span class="line">     * @param cmd 对应的指令</span><br><span class="line">     * @param v   值</span><br><span class="line">     */</span><br><span class="line">    private void executeCommand(String cmd, int v) &#123;</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">            case &quot;MOVE&quot;:</span><br><span class="line">                move(v);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;SPIN&quot;:</span><br><span class="line">                spin(v);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 移动距离</span><br><span class="line">     *</span><br><span class="line">     * @param distance 距离</span><br><span class="line">     */</span><br><span class="line">    private void move(int distance) &#123;</span><br><span class="line">        System.out.println(&quot;move &quot; + distance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 旋转角度</span><br><span class="line">     *</span><br><span class="line">     * @param angle 角度</span><br><span class="line">     */</span><br><span class="line">    private void spin(int angle) &#123;</span><br><span class="line">        System.out.println(&quot;spin &quot; + angle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void close() &#123;</span><br><span class="line">        synchronized (waitingQueue) &#123;</span><br><span class="line">            waitingQueue.forEach(c -&gt; System.out.print(&quot;*****************&quot; + c.seq + &quot;, &quot;));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s4.ax1x.com/2022/01/12/7nSNo6.png"></p>
<p>嘻嘻，解决啦~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面通过对 小车（Car） 的改造，将【收到命令立即执行命令】改为【收到命令后先放入优先队列】，然后【对命令进行有序执行】，顺利的解决了命令乱序的问题，真的是 Awesome ~</span><br></pre></td></tr></table></figure>

<h2><span id="三-消息丢失问题">三、消息丢失问题</span></h2><p>按顺序看下来的小伙伴们可以从上面了解到，在处理命令乱序问题时候，我们默认消息是不丢失的；但是呢，这个消息可并不是那么乐观，可能存在丢失的情况，这可就不好了，既然消息丢失，那我们的命令很可能无法接收到，也会出现很严重的后果！</p>
<p>当然，这个我们也是有解滴<del>有小伙伴可能会讲了：这不就用上面说到的TCP的可靠传输的方案来解决不就可以了嘛？没错，可以！但是笔者在这里小小偷了个懒，使用了一种不是很好但能快速解决问题的方案：多倍发包。至于TCP的可靠传输，可以下来自己尝试实现一下</del></p>
<p>我们看一下，什么是多倍发包。</p>
<p>举个栗子：快要过年了，小明想要抢票回家，但是呢，一票难求，大家都懂。所以小明在放票前，打开了10个相同的买票窗口，在到点时，快速的把每个窗口都点了一遍买票。由于小明的“多倍发包”，成功抢到了回家的票~</p>
<p>对于这个消息丢失，我们可以通过每次执行命令，发多个相同的指令，在小车接收端，对于相同序号的指令只执行一遍，这样就可以在即使部分指令丢了的情况下，也最大程度保证消息的完整。下面我们来实现一下吧~</p>
<p>首先，模拟消息丢失，在 Car 中的 startUp() 开始监听消息的方法中，加上随机丢失的代码，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Car.class</span><br><span class="line">    /**</span><br><span class="line">     * 开启小车</span><br><span class="line">     */</span><br><span class="line">    public synchronized void startUp() &#123;</span><br><span class="line"></span><br><span class="line">        // 开始监听 uuid room 的 rtc的消息</span><br><span class="line">        rtcClient.onListening(receiveMsg -&gt; &#123;</span><br><span class="line">            // 判断如果是心跳，则更新上一次探活时间</span><br><span class="line">            if (receiveMsg.key == null) &#123;</span><br><span class="line">                lastHeartbeatTime = receiveMsg.time;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 执行rtc消息传来的命令，让小车进行相应的动作</span><br><span class="line"></span><br><span class="line">                if(new Random().nextBoolean())&#123;</span><br><span class="line">                    // 模拟随机丢包</span><br><span class="line">                    System.out.println(&quot;消息丢失啦【&quot; + receiveMsg.seq + &quot;, &quot;+receiveMsg.key + &quot;: &quot; + receiveMsg.value + &quot;】&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">//                executeCommand(receiveMsg.key, receiveMsg.value);</span><br><span class="line">//                System.out.println(&quot;[ Seq: &quot; + receiveMsg.seq + &quot;, Cmd: &quot; + receiveMsg.key + &quot;, val: &quot; + receiveMsg.value + &quot; ]&quot;);</span><br><span class="line">                addWaitingQueue(receiveMsg); // 添加等待队列，来代替直接消费，这里使用优先队列保证顺序</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们执行一下，下图就是模拟在接收数据时，1、4两个命令都丢失了，导致程序无法正常执行命令。</p>
<p><img src="https://s4.ax1x.com/2022/01/13/7M9Wng.png"></p>
<p>丢包情况</p>
<p>接下来，添加多倍发包，在RtcClient中模拟，在OnListening()方法中，同样的指令发送多次，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// RtcClient.class</span><br><span class="line">    // 这里可以设置多倍发包的倍数</span><br><span class="line">    private static final int MULTIPLE_MESSAGE_SEND_TIMES = 3;</span><br><span class="line">// 监听发送来的心跳和消息，用线程来模拟</span><br><span class="line">    public void onListening(RtcEvent e) &#123;</span><br><span class="line"></span><br><span class="line">        // 定时发送心跳的线程</span><br><span class="line">        Thread t = new Thread(() -&gt; &#123;</span><br><span class="line">            for (int i = 0; !shutdown ; i++) &#123;</span><br><span class="line">                RtcMessage heartbeat = new RtcMessage();</span><br><span class="line">                heartbeat.key = null;</span><br><span class="line">                e.handleMessage(heartbeat);</span><br><span class="line">                System.out.println(&quot;心跳：&quot;+ i);</span><br><span class="line"></span><br><span class="line">                // 模拟中间接收到消息</span><br><span class="line">                if (i == 10) &#123;</span><br><span class="line"></span><br><span class="line">                    // 正确顺序，0-MOVE、1-SPIN、2-MOVE、3-SPIN、4-MOVE</span><br><span class="line">                    // 先生成顺序消息</span><br><span class="line">                    List&lt;RtcMessage&gt; msgList = new ArrayList&lt;&gt;(); // 使用list装</span><br><span class="line">                    for(int j = 0; j &lt; 5; j++)&#123;</span><br><span class="line">                        RtcMessage cmdMsg = new RtcMessage();</span><br><span class="line">                        if ((j &amp; 1) == 0)&#123;</span><br><span class="line">                            // 执行命令</span><br><span class="line">                            cmdMsg.key = &quot;MOVE&quot;;</span><br><span class="line">                            cmdMsg.value = 1000;</span><br><span class="line">                        &#125;else &#123;</span><br><span class="line">                            // 执行命令</span><br><span class="line">                            cmdMsg.key = &quot;SPIN&quot;;</span><br><span class="line">                            cmdMsg.value = 90;</span><br><span class="line">                        &#125;</span><br><span class="line">                        cmdMsg.seq = j;</span><br><span class="line">                        msgList.add(cmdMsg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 然后开启多线程发送指令</span><br><span class="line">                    msgList.forEach(msg -&gt; &#123;</span><br><span class="line">                        new Thread(() -&gt; &#123;</span><br><span class="line">                            // 多倍发包</span><br><span class="line">                            for (int j = 0; j &lt; MULTIPLE_MESSAGE_SEND_TIMES; j++) &#123;</span><br><span class="line">                                e.handleMessage(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;).start();</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 模拟掉线</span><br><span class="line">                if (i == 15)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(2000);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行，虽然这次能保证客户端能接收到每个Seq至少一条消息，但是，有些Seq的消息接收了多遍，如果都执行，那么也不符合预期。如下图，丢失了 【Seq&#x3D;0、0、1、1、2、3、4、4】 这八条消息，接受到了【Seq&#x3D;0、1、2、2、3、3、4】这七条消息，执行结果会如下，我们只能正确执行【0、1、2】三条消息的指令，不能继续往下执行了，因为当前队列头部为2，但是我们的lastSeq已经指向3，所以我们不能继续执行2.</p>
<p><img src="https://s4.ax1x.com/2022/01/13/7MCrb4.png"></p>
<p>多倍发包</p>
<p>所以我们继续修改Car小车接收端，如果命令被执行过，则直接丢掉，不进入阻塞队列，这样我们就可以继续有序的执行命令。只需要对监听 waitingQueue 的方法进行处理即可，让重复的命令包丢掉。下面是对Car类下的 initMsgWaitingQueue() 方法进行改造，在判断队列内消息的开始，先判断是否已经接收过这个Seq，接受过的话直接丢掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">Car.class</span><br><span class="line">    /**</span><br><span class="line">     * 初始化命令消费等待队列，开启线程，轮询等待队列，做到有顺序消费（执行命令）</span><br><span class="line">     */</span><br><span class="line">    private void initMsgWaitingQueue() &#123;</span><br><span class="line">        // 初始化首次消费命令顺序为0，以后每消费一次，序列号都+1，这个在tcp中可以作为ACK</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            for (; ; ) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(&quot;wait for command...&quot;);</span><br><span class="line">                if (waitingQueue.size() == 0) &#123;</span><br><span class="line">                    // 还没有消息</span><br><span class="line">//                    System.out.println(&quot;null message.&quot;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    RtcMessage receiveMsg = waitingQueue.peek();</span><br><span class="line">                    // 如果队首的Command的Seq小于当前执行的lastSeq，那么说明这条命令已经被执行了，所以丢掉</span><br><span class="line">                    if (receiveMsg.seq &lt; lastSeq.get())&#123;</span><br><span class="line">                        waitingQueue.poll(); // 丢掉</span><br><span class="line">                        continue; // 直接进行下一轮</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 如果本次有消息</span><br><span class="line">                    // 如果这次的消息序列号不等于上次+1，即 seq != lastSeq + 1，则还需要再把它入队列，再等等</span><br><span class="line">                    if (receiveMsg.seq != lastSeq.get()) &#123;</span><br><span class="line">                        // 既然不相等，那就需要再减回去</span><br><span class="line">                        System.out.printf(&quot;receiveMsg seq: %d, last seq: %d\n&quot;, receiveMsg.seq, lastSeq.get());</span><br><span class="line">                        System.out.println(&quot;not sequence message, continue wait...&quot;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // 若 seq = lastSeq + 1，则直接执行命令，进行消费</span><br><span class="line">                        executeCommand(receiveMsg.key, receiveMsg.value);</span><br><span class="line">                        lastSeq.addAndGet(1); // 标记上次消费的位置</span><br><span class="line">                        System.out.println(&quot;[ Seq: &quot; + receiveMsg.seq + &quot;, Cmd: &quot; + receiveMsg.key + &quot;, val: &quot; + receiveMsg.value + &quot; ]&quot;);</span><br><span class="line">                        waitingQueue.poll();</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.unlock();</span><br><span class="line"></span><br><span class="line">                // 等一下消息吧</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//                    try &#123;</span><br><span class="line">//                        RtcMessage receiveMsg = waitingQueue.poll(1, TimeUnit.SECONDS);</span><br><span class="line">//                        if (receiveMsg == null) &#123;</span><br><span class="line">//                            System.out.println(&quot;null message.&quot;);</span><br><span class="line">//                            continue;</span><br><span class="line">//                        &#125;</span><br><span class="line">//                        waitingQueue.forEach(c -&gt; System.out.println(c.seq));</span><br><span class="line">//                        // 如果这次的消息序列号不等于上次+1，即 seq != lastSeq + 1，则还需要再把它入队列，再等等</span><br><span class="line">//                        if (receiveMsg.seq != lastSeq.get() + 1) &#123;</span><br><span class="line">//                            addWaitingQueue(receiveMsg); // 再次入队</span><br><span class="line">//                            Thread.sleep(1000); // 再等待一秒吧</span><br><span class="line">//                            continue;</span><br><span class="line">//                        &#125;</span><br><span class="line">//                        // 若 seq = lastSeq + 1，则直接执行命令</span><br><span class="line">//                        executeCommand(receiveMsg.key, receiveMsg.value);</span><br><span class="line">//                        lastSeq.addAndGet(1); // 标记上次消费的位置</span><br><span class="line">//                        System.out.println(&quot;[ Seq: &quot; + receiveMsg.seq + &quot;, Cmd: &quot; + receiveMsg.key + &quot;, val: &quot; + receiveMsg.value + &quot; ]&quot;);</span><br><span class="line">//                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">//                        e.printStackTrace();</span><br><span class="line">//                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下面就是暴力发包的效果，即使丢了【1、2、2、3、3】消息，也可以看到后面按顺序执行了每一条指令，而且只执行了一次。</p>
<p><img src="https://s4.ax1x.com/2022/01/13/7MPnZ4.png"></p>
<p>最终结果</p>
<p>以上，就是对不稳定消息服务的改造全部内容~其中许多地方写的不够严谨，例如客户端重连后，Seq会重置，比较重点不是在这里嘛，而且解决这个问题应该也不是太复杂，大家可以搞一下嘛。</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="https://blog.lebear.top">Leisurelybear</a></p><p> <span>Link:  </span><a href="https://blog.lebear.top/2022/01/12/452/">https://blog.lebear.top/2022/01/12/452/</a></p><p> <span>Copyright:  </span><span>Copyright © 2019-2022 LeisurelyBear All rights reserved.</span></p></div><div class="post-paginator"><a class="nextSlogan" href="/2021/02/09/427/" title="Red Dead Redemption 2:  永远的亚瑟 · 摩根"><span>NextPost ></span><br><span class="nextTitle">Red Dead Redemption 2:  永远的亚瑟 · 摩根</span></a><div class="clear"></div></div><div id="comment"><div id="container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><script>const gitalk = new Gitalk({
  clientID: '7b32efbea888ff18bf71',
  clientSecret: 'd6d9022e73dfc0e9e55dc8ad8604a5aa73447595',
  repo: 'blog.lebear.top-comment',      // The repository of store comments,
  owner: 'Leisurelybear',
  admin: ['leisurelybear'],
  id: location.pathname,      // Ensure uniqueness and length less than 50
  distractionFreeMode: false  // Facebook-like distraction free mode
})
gitalk.render('container')
console.log("enable gitalk.")</script></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span> Modified based on &nbsp;</span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span><p class="footer-container"><span>Copyright © 2019-2022 LeisurelyBear All rights reserved.</span></p></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 80vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">一、掉线问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">二、消息时序问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">三、消息丢失问题</span></a></li></ol></div><!-- top--><!--i.fa.fa-arrow-up#go-up.close(aria-hidden="true")--><div class="back-to-top cd-top faa-float animated cd-is-visible" style="top: -900px;"></div></body></html>